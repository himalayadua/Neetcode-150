# Approach
========

We have two conditions to solve this question. The longest string should be
-   Substring
-   Without repeating characters


You just need to check that there are no repeated characters within a consecutive string of characters. To achieve this, you need to keep track of the characters currently forming the string. For this purpose, I considered three algorithms: one combining a sliding window and a set, and the second using a sliding window and a hash-based algorithm. The thrid is that the last position where each character was seen.

I'll explain them one by one.

## Solution 1 - Sliding Window & Set

First of all, we create

```python
left = 0
max_length = 0 (returned value)
char_set = set()
```

`left`Â is pointer of sliding window.\
`max_length`Â is a value we should return.\
`char_set`Â is to keep current characters forming the longest string with the two conditions above.

We will iterate through all characters one by one and createÂ `right pointer`Â of sliding window with for loop.

```python
for right in range(len(s)):
```

Let's begin!

```python
Input: s = "abcabcbb"
```

```python
"abcabcbb"
 r
 l

l is left of sliding window
r is right of sliding window
```

We foundÂ `a`. Every time we checkÂ `char_set`Â if we have the same character or not. In this case, we don't haveÂ `a`Â inÂ `char_set`, so addÂ `a`Â toÂ `char_set`.

```python
char_set = {a}
```

After that, we checkÂ `max length`.

```python
max_length = 0
current length = right - left + 1
```

### Why +1?

That's because current length of string isÂ `1`Â which is onlyÂ `a`, so if we don't addÂ `1`, we will calculateÂ `0(right) - 0(left) = 0`Â which is wrong answer.

This happens because index number usually starts fromÂ `0`Â but actual count we do in daily life startsÂ `1`. That's why we need to kind of convert an index number to a real number by addingÂ `+1`.

Let's go back to the main point.

```python
max_length = 1
```

Next, only right pointer move next. I'll speed up.

```python
"abcabcbb"
 lr

Do we have "b"? â†’ No
char_set = {a, b}

max_length = 2 (right(1) - left(0) + 1)
```

Next, only right pointer move next.

```python
"abcabcbb"
 l r

Do we have "c"? â†’ No
char_set = {a,b,c}

max_length = 3 (right(2) - left(0) + 1)
```

Next, only right pointer move next.

```python
"abcabcbb"
 l  r

Do we have "a"? â†’ Yes
```

In this case, we have duplicate numberÂ `a`, so we can't continue to expand the string. That's why it's time to moveÂ `left`Â to the next. And we have important point.

## Points

When we moveÂ `left`Â toÂ `index 1`,Â `a`Â atÂ `index 0`Â will be out of bounds, so we should removeÂ `a`Â fromÂ `char_set`, so that we can keep unique characters forming the current string.

In this case, we useÂ `while`Â loop, I'll explain why later.

```python
"abcabcbb"
 l  r

- Do we have "a"? â†’ Yes, remove "a" in char_set
char_set = {b,c}

- move left to the next
"abcabcbb"
  l r

- There is no "a" in char_set, we stop while looping.
- And add crreunt "a" to char_set
char_set = {b,c,a}

max_length = 3 (right(3) - left(1) + 1)
```

Next, only right pointer move next.

```python
"abcabcbb"
  l  r

- Do we have "b"? â†’ Yes, remove "b" in char_set
char_set = {c,a}

- move left to the next
"abcabcbb"
   l r

- There is no "b" in char_set, we stop while looping.
- And add crreunt "b" to char_set
char_set = {c,a,b}

max_length = 3 (right(4) - left(2) + 1)
```

Next, only right pointer move next.

```python
"abcabcbb"
   l  r

- Do we have "c"? â†’ Yes, remove "c" in char_set
char_set = {a,b}

- move left to the next
"abcabcbb"
    l r

- There is no "c" in char_set, we stop while looping.
- And add crreunt "c" to char_set
char_set = {a,b,c}

max_length = 3 (right(5) - left(3) + 1)
```

Next, only right pointer move next.

```python
"abcabcbb"
    l  r

- Do we have "b"? â†’ Yes, remove "a" in char_set
```

Wait! Why do we have to removeÂ `a`Â instead ofÂ `b`? That's becauseÂ `b`Â is now duplicate character betweenÂ `left`Â andÂ `right`, so we have to remove chracters until we findÂ `b`Â withÂ `left`Â pointer.

## Point 2
Let's look at the string deeply.

```python
"abcb"
 l  r
```

If we keepÂ `a`Â in the string, we have to also keep the firstÂ `b`Â becauseÂ `a`Â is outside of the firstÂ `b`Â in the string. If we want to remove the firstÂ `b`, we must removeÂ `a`Â before we remove the firstÂ `b`.Â This is substring.

In the end,

```python
"abcb"
   lr
```

Let's look at the process.

```python
"abcabcbb"
    l  r

- Do we have "b"? â†’ Yes, remove "a" in char_set
char_set = {b,c}

- Move left to the next
"abcabcbb"
     l r

- Do we have "b"? â†’ Yes, remove "b" in char_set
char_set = {c}

- Move left to the next
"abcabcbb"
      lr

- Do we have "b"? â†’ No, now we stop while loop

- Add current "b" to char_set
- char_set = {c,b}

max_length = 3 > (right(6) - left(5) + 1)

```

I hope now you understand why we use while loop when remove charcters.Â There is an case where we remove multiple characters.


I stop rest of explanation because we will repeat the same process.

```python
return 3
```

As you can see, we keepÂ `char_set`Â the same as the string between left and right when we add a current character toÂ `char_set`. That's why we can check if current character is duplicate or not.

EasyğŸ˜†!\
Let's see solution codes and step by step algorithm!

### Complexity

-   Time complexity:Â O(n)O(n)O(n)

-   Space complexity:Â O(1)O(1)O(1)

Constraints say "s consists of English letters, digits, symbols and spaces". I think we have fixed max size of characters consisting of the input string.


```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        left = max_length = 0
        char_set = set()

        for right in range(len(s)):
            while s[right] in char_set:
                char_set.remove(s[left])
                left += 1

            char_set.add(s[right])
            max_length = max(max_length, right - left + 1)

        return max_length
```


### Step by step algorithm

1.  Initialization:

```python
left = max_length = 0
char_set = set()
```

-   `left`: Marks the start of the current substring.
-   `max_length`: Tracks the length of the longest substring without repeating characters. Initialized to 0.
-   `char_set`: Keeps track of unique characters encountered so far, initialized as an empty set.

2.  Iterating over the string characters:

```python
for right in range(len(s)):
```

-   `right`: Represents the end of the current substring. It moves from 0 to the end of the string.

3.  Checking for repeating characters:

```python
while s[right] in char_set:
    char_set.remove(s[left])
    left += 1
```

-   This loop executes when the character at the 'right' index is already in theÂ `char_set`, meaning we have encountered a repeating character.
-   It removes characters from theÂ `char_set`Â and adjusts the 'left' pointer until the current character at 'right' is no longer in theÂ `char_set`. This effectively removes the characters from the substring that are causing the repetition.

4.  UpdatingÂ `char_set`Â andÂ `max_length`:

```python
char_set.add(s[right])
max_length = max(max_length, right - left + 1)
```

-   Adds the current character toÂ `char_set`Â since it's unique now.
-   UpdatesÂ `max_length`Â by taking the maximum between the currentÂ `max_length`Â and the length of the current substring (`right - left + 1`).

5.  ReturningÂ `max_length`:

```python
return max_length
```

-   After iterating through the entire string, the function returns the maximum length of the substring without repeating characters.


# Approach 2
## Solution 2 - Sliding Window and Hashing
=======================================

In solution 2, we use almost the same idea as solution 1 with Slinding Window and Hashing. In Python, we useÂ `HashMap`.

InÂ `HashMap`, we keep each character as a key and frequency of the characters as a value.

Every time we find a character, addÂ `1 frequency`Â toÂ `HashMap`. Since this question requires us to find the longest substring without repeating characters, so if we have more thanÂ `2 frequency`Â of the current character, we addÂ `-1`Â toÂ `HashMap`Â until we haveÂ `1 frequency`Â of the current character and move left pointer to the next at the same time.

After that, this is the same as solution 1. Just compareÂ `max length`

```python
max_length = max(max_length, right - left + 1)
```

EasyğŸ˜„ï¼\
Let's see solution codes and step by step algorithm!

* * * * *

## Complexity
==========

-   Time complexity:Â O(n)O(n)O(n)

-   Space complexity:Â O(1)O(1)O(1)

Constraints say "s consists of English letters, digits, symbols and spaces". I think we have fixed max size of characters consisting of the input string.

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:

        max_length = left = 0
        count = {}

        for right, c in enumerate(s):
            count[c] = 1 + count.get(c, 0)
            while count[c] > 1:
                count[s[left]] -= 1
                left += 1
        
            max_length = max(max_length, right - left + 1)

        return max_length
```

## Step by step algorithm
----------------------

1.  Initialization:

```python
max_length = left = 0
count = {}
```

-   `max_length`: Represents the length of the longest substring without repeating characters found so far. Initialized to 0.
-   `left`: Marks the start index of the current substring.
-   `count`: A dictionary used to store the count of characters encountered in the current substring.

2.  Iterating Over the String:

```python
for right, c in enumerate(s):
```

-   `right`: Represents the end index of the current substring. It is updated usingÂ `enumerate(s)`, which returns both the index and the character at that index in the string.
-   `c`: Represents the character at the current index.

3.  Updating the Character Count:

```python
count[c] = 1 + count.get(c, 0)
```

-   This line updates the count of the current characterÂ `c`Â in theÂ `count`Â dictionary.
-   IfÂ `c`Â is not present in the dictionary, it initializes its count to 1. Otherwise, it increments its count by 1.

4.  Adjusting the Left Pointer:

```python
while count[c] > 1:
    count[s[left]] -= 1
    left += 1
```

-   This while loop adjusts theÂ `left`Â pointer as long as there are repeating characters in the current substring.
-   It decreases the count of the character at indexÂ `left`Â and incrementsÂ `left`Â by 1 until there are no repeating characters.

5.  Updating the Maximum Length:

```python
max_length = max(max_length, right - left + 1)
```

-   This line updates the maximum length (`max_length`) of the substring without repeating characters.
-   It calculates the length of the current substring (`right - left + 1`) and compares it with the current maximum length (`max_length`). If the current substring is longer, it updatesÂ `max_length`.

6.  Returning the Result:

```python
return max_length
```

-   After iterating through the entire string, the function returns the maximum length of the substring without repeating characters.

In summary, this algorithm efficiently finds the length of the longest substring without repeating characters using two pointers (`left`Â andÂ `right`) and a dictionary (`count`) to keep track of character counts. It iterates through the string once, making it a linear time complexity algorithm.

# Approach 3
## Solution 3 - the last position where each character was seen
============================================================

In the solution 3, we also iterate through all characters one by one. That isÂ `right`Â pointer.

We updateÂ `left`Â pointer withÂ `HashMap`. InÂ `HashMap`, we keep each character as a key and the last position where each character was seenã€€as a value.

Do you remember this example in solution 1?

```python
"abcb"
 l  r
```

Let's call HashMapÂ `last_seen`.

In this case,Â `last_seen`Â should have this

```python
last_seen = {a:0, b:1, c:2}

last position of a is 0
last position of b is 1
last position of c is 2

current max length shold be 3 (= abc)
```

Now we find the secondÂ `b`Â at indexÂ `3`. As I explain in solution 1, we have to remove characters until we have unique characters betweenÂ `left`Â andÂ `right`.

`left`Â pointer is at indexÂ `0`Â and the last position whereÂ `b`Â was seen is indexÂ `1`, so that's why we should updateÂ `left`Â pointer withÂ `1`.

One more important thing is that if we updateÂ `left`Â withÂ `1`, we haveÂ `bcb`Â as a string which is including duplicate characters.

That's why we should updateÂ `left`Â pointer withÂ `the last position + 1`.

```python
left = last_seen[character(= b)] + 1
= 2
```

Then compare max length

```python
max_length = max(max_length, right - left + 1)
```

EasyğŸ˜„!\
Let's see solution codes and step by step algorithm!

* * * * *

## Complexity
==========

-   Time complexity:Â O(n)O(n)O(n)

-   Space complexity:Â O(1)O(1)O(1)

Constraints say "s consists of English letters, digits, symbols and spaces". I think we have fixed max size of characters consisting of the input string.

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        max_length = 0
        left = 0
        last_seen = {}

        for right, c in enumerate(s):
            if c in last_seen and last_seen[c] >= left:
                left = last_seen[c] + 1
            
            max_length = max(max_length, right - left + 1)
            last_seen[c] = right

        return max_length
```

## Step by step algorithm
----------------------

1.  Initialization:

```python
max_length = 0
left = 0
last_seen = {}
```

-   `max_length`: Keeps track of the length of the longest substring without repeating characters.
-   `left`: Marks the start index of the current substring.
-   `last_seen`: A dictionary to store the last seen index of each character in the string.

2.  Iterating Over the String:

```python
for right, c in enumerate(s):
```

-   `right`: Represents the current index of the characterÂ `c`Â being processed.
-   `c`: Represents the current character being processed.

3.  Checking for Repeating Characters:

```python
if c in last_seen and last_seen[c] >= left:
    left = last_seen[c] + 1
```

-   If the characterÂ `c`Â is present inÂ `last_seen`Â and its last seen index is greater than or equal toÂ `left`Â (the start index of the current substring), it means thatÂ `c`Â is repeating within the current substring.
-   In such a case, we updateÂ `left`Â to the index next to the last occurrence ofÂ `c`.

4.  UpdatingÂ `max_length`:

```python
max_length = max(max_length, right - left + 1)
```

-   UpdateÂ `max_length`Â with the maximum value between its current value and the length of the current substring (`right - left + 1`).
-   `right - left + 1`Â represents the length of the current substring without repeating characters.

5.  UpdatingÂ `last_seen`:

```python
last_seen[c] = right
```

-   Update theÂ `last_seen`Â dictionary with the indexÂ `right`Â where the characterÂ `c`Â was last seen.

6.  Returning the Result:

```python
return max_length
```

-   After iterating through the entire string, return the maximum length of the substring without repeating characters.